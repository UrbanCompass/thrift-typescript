/* tslint:disable */
/* eslint-disable */
/*
 * Autogenerated by @uc/thrift-typescript v3.7.6
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
*/
import Int64 from "node-int64";
import * as thrift from "test-lib";
import * as __ROOT_NAMESPACE__ from "./../../..";
import * as com_test_operation from "./../operation";
import * as NotAGoodIdea from "./NotAGoodIdea";
import * as Work from "./Work";
import * as Choice from "./Choice";
import * as com_test_common from "./../common";
import * as TypedMap from "./TypedMap";
import * as CommonStruct from "./CommonStruct";
export interface IPing__Args__Args {
}
export class Ping__Args {
    constructor() {
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("Ping__Args");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): Ping__Args {
        input.readStructBegin();
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new Ping__Args();
    }
}
export interface IAdd__Args__Args {
    num1: number;
    num2: number;
}
export class Add__Args {
    public num1: number;
    public num2: number;
    constructor(args: IAdd__Args__Args) {
        if (args != null && args.num1 != null) {
            this.num1 = args.num1;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[num1] is unset!");
        }
        if (args != null && args.num2 != null) {
            this.num2 = args.num2;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[num2] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("Add__Args");
        if (this.num1 != null) {
            output.writeFieldBegin("num1", thrift.Thrift.Type.I32, 1);
            output.writeI32(this.num1);
            output.writeFieldEnd();
        }
        if (this.num2 != null) {
            output.writeFieldBegin("num2", thrift.Thrift.Type.I32, 2);
            output.writeI32(this.num2);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): Add__Args {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_1: number = input.readI32();
                        _args.num1 = value_1;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_2: number = input.readI32();
                        _args.num2 = value_2;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.num1 !== undefined && _args.num2 !== undefined) {
            return new Add__Args(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read Add__Args from input");
        }
    }
}
export interface IAddInt64__Args__Args {
    num1: number | Int64;
    num2: number | Int64;
}
export class AddInt64__Args {
    public num1: Int64;
    public num2: Int64;
    constructor(args: IAddInt64__Args__Args) {
        if (args != null && args.num1 != null) {
            if (typeof args.num1 === "number") {
                this.num1 = new Int64(args.num1);
            }
            else {
                this.num1 = args.num1;
            }
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[num1] is unset!");
        }
        if (args != null && args.num2 != null) {
            if (typeof args.num2 === "number") {
                this.num2 = new Int64(args.num2);
            }
            else {
                this.num2 = args.num2;
            }
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[num2] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("AddInt64__Args");
        if (this.num1 != null) {
            output.writeFieldBegin("num1", thrift.Thrift.Type.I64, 1);
            output.writeI64(this.num1);
            output.writeFieldEnd();
        }
        if (this.num2 != null) {
            output.writeFieldBegin("num2", thrift.Thrift.Type.I64, 2);
            output.writeI64(this.num2);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): AddInt64__Args {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.I64) {
                        const value_3: Int64 = input.readI64();
                        _args.num1 = value_3;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.I64) {
                        const value_4: Int64 = input.readI64();
                        _args.num2 = value_4;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.num1 !== undefined && _args.num2 !== undefined) {
            return new AddInt64__Args(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read AddInt64__Args from input");
        }
    }
}
export interface IAddWithContext__Args__Args {
    num1: number;
    num2: number;
}
export class AddWithContext__Args {
    public num1: number;
    public num2: number;
    constructor(args: IAddWithContext__Args__Args) {
        if (args != null && args.num1 != null) {
            this.num1 = args.num1;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[num1] is unset!");
        }
        if (args != null && args.num2 != null) {
            this.num2 = args.num2;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[num2] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("AddWithContext__Args");
        if (this.num1 != null) {
            output.writeFieldBegin("num1", thrift.Thrift.Type.I32, 1);
            output.writeI32(this.num1);
            output.writeFieldEnd();
        }
        if (this.num2 != null) {
            output.writeFieldBegin("num2", thrift.Thrift.Type.I32, 2);
            output.writeI32(this.num2);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): AddWithContext__Args {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_5: number = input.readI32();
                        _args.num1 = value_5;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_6: number = input.readI32();
                        _args.num2 = value_6;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.num1 !== undefined && _args.num2 !== undefined) {
            return new AddWithContext__Args(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read AddWithContext__Args from input");
        }
    }
}
export interface ICalculate__Args__Args {
    logid: number;
    work: Work.Work;
}
export class Calculate__Args {
    public logid: number;
    public work: Work.Work;
    constructor(args: ICalculate__Args__Args) {
        if (args != null && args.logid != null) {
            this.logid = args.logid;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[logid] is unset!");
        }
        if (args != null && args.work != null) {
            this.work = args.work;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[work] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("Calculate__Args");
        if (this.logid != null) {
            output.writeFieldBegin("logid", thrift.Thrift.Type.I32, 1);
            output.writeI32(this.logid);
            output.writeFieldEnd();
        }
        if (this.work != null) {
            output.writeFieldBegin("work", thrift.Thrift.Type.STRUCT, 2);
            this.work.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): Calculate__Args {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_7: number = input.readI32();
                        _args.logid = value_7;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_8: Work.Work = Work.Work.read(input);
                        _args.work = value_8;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.logid !== undefined && _args.work !== undefined) {
            return new Calculate__Args(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read Calculate__Args from input");
        }
    }
}
export interface IEchoBinary__Args__Args {
    word: Buffer;
}
export class EchoBinary__Args {
    public word: Buffer;
    constructor(args: IEchoBinary__Args__Args) {
        if (args != null && args.word != null) {
            this.word = args.word;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[word] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("EchoBinary__Args");
        if (this.word != null) {
            output.writeFieldBegin("word", thrift.Thrift.Type.STRING, 1);
            output.writeBinary(this.word);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): EchoBinary__Args {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_9: Buffer = input.readBinary();
                        _args.word = value_9;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.word !== undefined) {
            return new EchoBinary__Args(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read EchoBinary__Args from input");
        }
    }
}
export interface IEchoString__Args__Args {
    word: string;
}
export class EchoString__Args {
    public word: string;
    constructor(args: IEchoString__Args__Args) {
        if (args != null && args.word != null) {
            this.word = args.word;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[word] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("EchoString__Args");
        if (this.word != null) {
            output.writeFieldBegin("word", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.word);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): EchoString__Args {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_10: string = input.readString();
                        _args.word = value_10;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.word !== undefined) {
            return new EchoString__Args(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read EchoString__Args from input");
        }
    }
}
export interface ICheckName__Args__Args {
    choice: Choice.Choice;
}
export class CheckName__Args {
    public choice: Choice.Choice;
    constructor(args: ICheckName__Args__Args) {
        if (args != null && args.choice != null) {
            this.choice = args.choice;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[choice] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CheckName__Args");
        if (this.choice != null) {
            output.writeFieldBegin("choice", thrift.Thrift.Type.STRUCT, 1);
            this.choice.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CheckName__Args {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_11: Choice.Choice = Choice.Choice.read(input);
                        _args.choice = value_11;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.choice !== undefined) {
            return new CheckName__Args(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CheckName__Args from input");
        }
    }
}
export interface ICheckOptional__Args__Args {
    type?: string;
}
export class CheckOptional__Args {
    public type?: string;
    constructor(args?: ICheckOptional__Args__Args) {
        if (args != null && args.type != null) {
            this.type = args.type;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CheckOptional__Args");
        if (this.type != null) {
            output.writeFieldBegin("type", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.type);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CheckOptional__Args {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_12: string = input.readString();
                        _args.type = value_12;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CheckOptional__Args(_args);
    }
}
export interface IMapOneList__Args__Args {
    arg: Array<number>;
}
export class MapOneList__Args {
    public arg: Array<number>;
    constructor(args: IMapOneList__Args__Args) {
        if (args != null && args.arg != null) {
            this.arg = args.arg;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[arg] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("MapOneList__Args");
        if (this.arg != null) {
            output.writeFieldBegin("arg", thrift.Thrift.Type.LIST, 1);
            output.writeListBegin(thrift.Thrift.Type.I32, this.arg.length);
            this.arg.forEach((value_13: number): void => {
                output.writeI32(value_13);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): MapOneList__Args {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_14: Array<number> = new Array<number>();
                        const metadata_1: thrift.TList = input.readListBegin();
                        const size_1: number = metadata_1.size;
                        for (let i_1: number = 0; i_1 < size_1; i_1++) {
                            const value_15: number = input.readI32();
                            value_14.push(value_15);
                        }
                        input.readListEnd();
                        _args.arg = value_14;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.arg !== undefined) {
            return new MapOneList__Args(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read MapOneList__Args from input");
        }
    }
}
export interface IMapValues__Args__Args {
    arg: Map<string, number>;
}
export class MapValues__Args {
    public arg: Map<string, number>;
    constructor(args: IMapValues__Args__Args) {
        if (args != null && args.arg != null) {
            this.arg = args.arg;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[arg] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("MapValues__Args");
        if (this.arg != null) {
            output.writeFieldBegin("arg", thrift.Thrift.Type.MAP, 1);
            output.writeMapBegin(thrift.Thrift.Type.STRING, thrift.Thrift.Type.I32, this.arg.size);
            this.arg.forEach((value_16: number, key_1: string): void => {
                output.writeString(key_1);
                output.writeI32(value_16);
            });
            output.writeMapEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): MapValues__Args {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.MAP) {
                        const value_17: Map<string, number> = new Map<string, number>();
                        const metadata_2: thrift.TMap = input.readMapBegin();
                        const size_2: number = metadata_2.size;
                        for (let i_2: number = 0; i_2 < size_2; i_2++) {
                            const key_2: string = input.readString();
                            const value_18: number = input.readI32();
                            value_17.set(key_2, value_18);
                        }
                        input.readMapEnd();
                        _args.arg = value_17;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.arg !== undefined) {
            return new MapValues__Args(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read MapValues__Args from input");
        }
    }
}
export interface IListToMap__Args__Args {
    arg: Array<Array<string>>;
}
export class ListToMap__Args {
    public arg: Array<Array<string>>;
    constructor(args: IListToMap__Args__Args) {
        if (args != null && args.arg != null) {
            this.arg = args.arg;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[arg] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ListToMap__Args");
        if (this.arg != null) {
            output.writeFieldBegin("arg", thrift.Thrift.Type.LIST, 1);
            output.writeListBegin(thrift.Thrift.Type.LIST, this.arg.length);
            this.arg.forEach((value_19: Array<string>): void => {
                output.writeListBegin(thrift.Thrift.Type.STRING, value_19.length);
                value_19.forEach((value_20: string): void => {
                    output.writeString(value_20);
                });
                output.writeListEnd();
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ListToMap__Args {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_21: Array<Array<string>> = new Array<Array<string>>();
                        const metadata_3: thrift.TList = input.readListBegin();
                        const size_3: number = metadata_3.size;
                        for (let i_3: number = 0; i_3 < size_3; i_3++) {
                            const value_22: Array<string> = new Array<string>();
                            const metadata_4: thrift.TList = input.readListBegin();
                            const size_4: number = metadata_4.size;
                            for (let i_4: number = 0; i_4 < size_4; i_4++) {
                                const value_23: string = input.readString();
                                value_22.push(value_23);
                            }
                            input.readListEnd();
                            value_21.push(value_22);
                        }
                        input.readListEnd();
                        _args.arg = value_21;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.arg !== undefined) {
            return new ListToMap__Args(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ListToMap__Args from input");
        }
    }
}
export interface IFetchThing__Args__Args {
}
export class FetchThing__Args {
    constructor() {
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("FetchThing__Args");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): FetchThing__Args {
        input.readStructBegin();
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new FetchThing__Args();
    }
}
export interface IFetchMap__Args__Args {
}
export class FetchMap__Args {
    constructor() {
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("FetchMap__Args");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): FetchMap__Args {
        input.readStructBegin();
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new FetchMap__Args();
    }
}
export interface IZip__Args__Args {
}
export class Zip__Args {
    constructor() {
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("Zip__Args");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): Zip__Args {
        input.readStructBegin();
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new Zip__Args();
    }
}
export interface IPing__Result__Args {
    success?: void;
}
export class Ping__Result {
    public success?: void;
    constructor(args?: IPing__Result__Args) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("Ping__Result");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): Ping__Result {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.VOID) {
                        input.skip(fieldType);
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new Ping__Result(_args);
    }
}
export interface IAdd__Result__Args {
    success?: number;
    exp?: com_test_operation.JankyResult;
}
export class Add__Result {
    public success?: number;
    public exp?: com_test_operation.JankyResult;
    constructor(args?: IAdd__Result__Args) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.exp != null) {
            this.exp = args.exp;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("Add__Result");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.I32, 0);
            output.writeI32(this.success);
            output.writeFieldEnd();
        }
        if (this.exp != null) {
            output.writeFieldBegin("exp", thrift.Thrift.Type.STRUCT, 1);
            this.exp.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): Add__Result {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_24: number = input.readI32();
                        _args.success = value_24;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_25: com_test_operation.JankyResult = com_test_operation.JankyResult.read(input);
                        _args.exp = value_25;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new Add__Result(_args);
    }
}
export interface IAddInt64__Result__Args {
    success?: number | Int64;
    exp?: NotAGoodIdea.NotAGoodIdea;
}
export class AddInt64__Result {
    public success?: Int64;
    public exp?: NotAGoodIdea.NotAGoodIdea;
    constructor(args?: IAddInt64__Result__Args) {
        if (args != null && args.success != null) {
            if (typeof args.success === "number") {
                this.success = new Int64(args.success);
            }
            else {
                this.success = args.success;
            }
        }
        if (args != null && args.exp != null) {
            this.exp = args.exp;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("AddInt64__Result");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.I64, 0);
            output.writeI64(this.success);
            output.writeFieldEnd();
        }
        if (this.exp != null) {
            output.writeFieldBegin("exp", thrift.Thrift.Type.STRUCT, 1);
            this.exp.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): AddInt64__Result {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.I64) {
                        const value_26: Int64 = input.readI64();
                        _args.success = value_26;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_27: NotAGoodIdea.NotAGoodIdea = NotAGoodIdea.NotAGoodIdea.read(input);
                        _args.exp = value_27;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new AddInt64__Result(_args);
    }
}
export interface IAddWithContext__Result__Args {
    success?: number;
}
export class AddWithContext__Result {
    public success?: number;
    constructor(args?: IAddWithContext__Result__Args) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("AddWithContext__Result");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.I32, 0);
            output.writeI32(this.success);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): AddWithContext__Result {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_28: number = input.readI32();
                        _args.success = value_28;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new AddWithContext__Result(_args);
    }
}
export interface ICalculate__Result__Args {
    success?: number;
    ouch?: com_test_operation.JankyOperation;
}
export class Calculate__Result {
    public success?: number;
    public ouch?: com_test_operation.JankyOperation;
    constructor(args?: ICalculate__Result__Args) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.ouch != null) {
            this.ouch = args.ouch;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("Calculate__Result");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.I32, 0);
            output.writeI32(this.success);
            output.writeFieldEnd();
        }
        if (this.ouch != null) {
            output.writeFieldBegin("ouch", thrift.Thrift.Type.STRUCT, 1);
            this.ouch.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): Calculate__Result {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_29: number = input.readI32();
                        _args.success = value_29;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_30: com_test_operation.JankyOperation = com_test_operation.JankyOperation.read(input);
                        _args.ouch = value_30;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new Calculate__Result(_args);
    }
}
export interface IEchoBinary__Result__Args {
    success?: string;
}
export class EchoBinary__Result {
    public success?: string;
    constructor(args?: IEchoBinary__Result__Args) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("EchoBinary__Result");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRING, 0);
            output.writeString(this.success);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): EchoBinary__Result {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_31: string = input.readString();
                        _args.success = value_31;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new EchoBinary__Result(_args);
    }
}
export interface IEchoString__Result__Args {
    success?: string;
}
export class EchoString__Result {
    public success?: string;
    constructor(args?: IEchoString__Result__Args) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("EchoString__Result");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRING, 0);
            output.writeString(this.success);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): EchoString__Result {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_32: string = input.readString();
                        _args.success = value_32;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new EchoString__Result(_args);
    }
}
export interface ICheckName__Result__Args {
    success?: string;
}
export class CheckName__Result {
    public success?: string;
    constructor(args?: ICheckName__Result__Args) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CheckName__Result");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRING, 0);
            output.writeString(this.success);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CheckName__Result {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_33: string = input.readString();
                        _args.success = value_33;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CheckName__Result(_args);
    }
}
export interface ICheckOptional__Result__Args {
    success?: string;
}
export class CheckOptional__Result {
    public success?: string;
    constructor(args?: ICheckOptional__Result__Args) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CheckOptional__Result");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRING, 0);
            output.writeString(this.success);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CheckOptional__Result {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_34: string = input.readString();
                        _args.success = value_34;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CheckOptional__Result(_args);
    }
}
export interface IMapOneList__Result__Args {
    success?: Array<number>;
}
export class MapOneList__Result {
    public success?: Array<number>;
    constructor(args?: IMapOneList__Result__Args) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("MapOneList__Result");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.I32, this.success.length);
            this.success.forEach((value_35: number): void => {
                output.writeI32(value_35);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): MapOneList__Result {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_36: Array<number> = new Array<number>();
                        const metadata_5: thrift.TList = input.readListBegin();
                        const size_5: number = metadata_5.size;
                        for (let i_5: number = 0; i_5 < size_5; i_5++) {
                            const value_37: number = input.readI32();
                            value_36.push(value_37);
                        }
                        input.readListEnd();
                        _args.success = value_36;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new MapOneList__Result(_args);
    }
}
export interface IMapValues__Result__Args {
    success?: Array<number>;
}
export class MapValues__Result {
    public success?: Array<number>;
    constructor(args?: IMapValues__Result__Args) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("MapValues__Result");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.I32, this.success.length);
            this.success.forEach((value_38: number): void => {
                output.writeI32(value_38);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): MapValues__Result {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_39: Array<number> = new Array<number>();
                        const metadata_6: thrift.TList = input.readListBegin();
                        const size_6: number = metadata_6.size;
                        for (let i_6: number = 0; i_6 < size_6; i_6++) {
                            const value_40: number = input.readI32();
                            value_39.push(value_40);
                        }
                        input.readListEnd();
                        _args.success = value_39;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new MapValues__Result(_args);
    }
}
export interface IListToMap__Result__Args {
    success?: Map<string, string>;
}
export class ListToMap__Result {
    public success?: Map<string, string>;
    constructor(args?: IListToMap__Result__Args) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ListToMap__Result");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.MAP, 0);
            output.writeMapBegin(thrift.Thrift.Type.STRING, thrift.Thrift.Type.STRING, this.success.size);
            this.success.forEach((value_41: string, key_3: string): void => {
                output.writeString(key_3);
                output.writeString(value_41);
            });
            output.writeMapEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ListToMap__Result {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.MAP) {
                        const value_42: Map<string, string> = new Map<string, string>();
                        const metadata_7: thrift.TMap = input.readMapBegin();
                        const size_7: number = metadata_7.size;
                        for (let i_7: number = 0; i_7 < size_7; i_7++) {
                            const key_4: string = input.readString();
                            const value_43: string = input.readString();
                            value_42.set(key_4, value_43);
                        }
                        input.readMapEnd();
                        _args.success = value_42;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ListToMap__Result(_args);
    }
}
export interface IFetchThing__Result__Args {
    success?: com_test_common.CommonStruct;
}
export class FetchThing__Result {
    public success?: com_test_common.CommonStruct;
    constructor(args?: IFetchThing__Result__Args) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("FetchThing__Result");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): FetchThing__Result {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_44: com_test_common.CommonStruct = com_test_common.CommonStruct.read(input);
                        _args.success = value_44;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new FetchThing__Result(_args);
    }
}
export interface IFetchMap__Result__Args {
    success?: TypedMap.TypedMap;
}
export class FetchMap__Result {
    public success?: TypedMap.TypedMap;
    constructor(args?: IFetchMap__Result__Args) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("FetchMap__Result");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.MAP, 0);
            output.writeMapBegin(thrift.Thrift.Type.STRING, thrift.Thrift.Type.STRUCT, this.success.size);
            this.success.forEach((value_45: CommonStruct.CommonStruct, key_5: string): void => {
                output.writeString(key_5);
                value_45.write(output);
            });
            output.writeMapEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): FetchMap__Result {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.MAP) {
                        const value_46: Map<string, CommonStruct.CommonStruct> = new Map<string, CommonStruct.CommonStruct>();
                        const metadata_8: thrift.TMap = input.readMapBegin();
                        const size_8: number = metadata_8.size;
                        for (let i_8: number = 0; i_8 < size_8; i_8++) {
                            const key_6: string = input.readString();
                            const value_47: CommonStruct.CommonStruct = CommonStruct.CommonStruct.read(input);
                            value_46.set(key_6, value_47);
                        }
                        input.readMapEnd();
                        _args.success = value_46;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new FetchMap__Result(_args);
    }
}
export interface IZip__Result__Args {
    success?: void;
}
export class Zip__Result {
    public success?: void;
    constructor(args?: IZip__Result__Args) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("Zip__Result");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): Zip__Result {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.VOID) {
                        input.skip(fieldType);
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new Zip__Result(_args);
    }
}
export class Client extends __ROOT_NAMESPACE__.SharedService.Client {
    public _seqid: number;
    public _reqs: {
        [name: number]: (err: Error | object | undefined, val?: any) => void;
    };
    public output: thrift.TTransport;
    public protocol: new (trans: thrift.TTransport) => thrift.TProtocol;
    constructor(output: thrift.TTransport, protocol: new (trans: thrift.TTransport) => thrift.TProtocol) {
        super(output, protocol);
        this._seqid = 0;
        this._reqs = {};
        this.output = output;
        this.protocol = protocol;
    }
    public incrementSeqId(): number {
        return this._seqid += 1;
    }
    public ping(): Promise<void> {
        const requestId: number = this.incrementSeqId();
        return new Promise<void>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_ping(requestId);
        });
    }
    public add(num1: number, num2: number): Promise<number> {
        const requestId: number = this.incrementSeqId();
        return new Promise<number>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_add(num1, num2, requestId);
        });
    }
    public addInt64(num1: Int64, num2: Int64): Promise<Int64> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Int64>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_addInt64(num1, num2, requestId);
        });
    }
    public addWithContext(num1: number, num2: number): Promise<number> {
        const requestId: number = this.incrementSeqId();
        return new Promise<number>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_addWithContext(num1, num2, requestId);
        });
    }
    public calculate(logid: number, work: Work.Work): Promise<number> {
        const requestId: number = this.incrementSeqId();
        return new Promise<number>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_calculate(logid, work, requestId);
        });
    }
    public echoBinary(word: Buffer): Promise<string> {
        const requestId: number = this.incrementSeqId();
        return new Promise<string>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_echoBinary(word, requestId);
        });
    }
    public echoString(word: string): Promise<string> {
        const requestId: number = this.incrementSeqId();
        return new Promise<string>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_echoString(word, requestId);
        });
    }
    public checkName(choice: Choice.Choice): Promise<string> {
        const requestId: number = this.incrementSeqId();
        return new Promise<string>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_checkName(choice, requestId);
        });
    }
    public checkOptional(type?: string): Promise<string> {
        const requestId: number = this.incrementSeqId();
        return new Promise<string>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_checkOptional(type, requestId);
        });
    }
    public mapOneList(arg: Array<number>): Promise<Array<number>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<number>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_mapOneList(arg, requestId);
        });
    }
    public mapValues(arg: Map<string, number>): Promise<Array<number>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<number>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_mapValues(arg, requestId);
        });
    }
    public listToMap(arg: Array<Array<string>>): Promise<Map<string, string>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Map<string, string>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_listToMap(arg, requestId);
        });
    }
    public fetchThing(): Promise<com_test_common.CommonStruct> {
        const requestId: number = this.incrementSeqId();
        return new Promise<com_test_common.CommonStruct>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_fetchThing(requestId);
        });
    }
    public fetchMap(): Promise<TypedMap.TypedMap> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TypedMap.TypedMap>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_fetchMap(requestId);
        });
    }
    public zip(): Promise<void> {
        const requestId: number = this.incrementSeqId();
        return new Promise<void>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_zip(requestId);
        });
    }
    public send_ping(requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("ping", thrift.Thrift.MessageType.CALL, requestId);
        const args: Ping__Args = new Ping__Args();
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_add(num1: number, num2: number, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("add", thrift.Thrift.MessageType.CALL, requestId);
        const args: Add__Args = new Add__Args({ num1, num2 });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_addInt64(num1: Int64, num2: Int64, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("addInt64", thrift.Thrift.MessageType.CALL, requestId);
        const args: AddInt64__Args = new AddInt64__Args({ num1, num2 });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_addWithContext(num1: number, num2: number, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("addWithContext", thrift.Thrift.MessageType.CALL, requestId);
        const args: AddWithContext__Args = new AddWithContext__Args({ num1, num2 });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_calculate(logid: number, work: Work.Work, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("calculate", thrift.Thrift.MessageType.CALL, requestId);
        const args: Calculate__Args = new Calculate__Args({ logid, work });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_echoBinary(word: Buffer, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("echoBinary", thrift.Thrift.MessageType.CALL, requestId);
        const args: EchoBinary__Args = new EchoBinary__Args({ word });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_echoString(word: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("echoString", thrift.Thrift.MessageType.CALL, requestId);
        const args: EchoString__Args = new EchoString__Args({ word });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_checkName(choice: Choice.Choice, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("checkName", thrift.Thrift.MessageType.CALL, requestId);
        const args: CheckName__Args = new CheckName__Args({ choice });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_checkOptional(type: string | undefined, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("checkOptional", thrift.Thrift.MessageType.CALL, requestId);
        const args: CheckOptional__Args = new CheckOptional__Args({ type });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_mapOneList(arg: Array<number>, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("mapOneList", thrift.Thrift.MessageType.CALL, requestId);
        const args: MapOneList__Args = new MapOneList__Args({ arg });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_mapValues(arg: Map<string, number>, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("mapValues", thrift.Thrift.MessageType.CALL, requestId);
        const args: MapValues__Args = new MapValues__Args({ arg });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_listToMap(arg: Array<Array<string>>, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("listToMap", thrift.Thrift.MessageType.CALL, requestId);
        const args: ListToMap__Args = new ListToMap__Args({ arg });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_fetchThing(requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("fetchThing", thrift.Thrift.MessageType.CALL, requestId);
        const args: FetchThing__Args = new FetchThing__Args();
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_fetchMap(requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("fetchMap", thrift.Thrift.MessageType.CALL, requestId);
        const args: FetchMap__Args = new FetchMap__Args();
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_zip(requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("zip", thrift.Thrift.MessageType.CALL, requestId);
        const args: Zip__Args = new Zip__Args();
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public recv_ping(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            input.readMessageEnd();
            return callback(undefined);
        }
    }
    public recv_add(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: Add__Result = Add__Result.read(input);
            input.readMessageEnd();
            if (result.exp != null) {
                return callback(result.exp);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "add failed: unknown result"));
                }
            }
        }
    }
    public recv_addInt64(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: AddInt64__Result = AddInt64__Result.read(input);
            input.readMessageEnd();
            if (result.exp != null) {
                return callback(result.exp);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "addInt64 failed: unknown result"));
                }
            }
        }
    }
    public recv_addWithContext(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: AddWithContext__Result = AddWithContext__Result.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "addWithContext failed: unknown result"));
            }
        }
    }
    public recv_calculate(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: Calculate__Result = Calculate__Result.read(input);
            input.readMessageEnd();
            if (result.ouch != null) {
                return callback(result.ouch);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "calculate failed: unknown result"));
                }
            }
        }
    }
    public recv_echoBinary(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: EchoBinary__Result = EchoBinary__Result.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "echoBinary failed: unknown result"));
            }
        }
    }
    public recv_echoString(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: EchoString__Result = EchoString__Result.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "echoString failed: unknown result"));
            }
        }
    }
    public recv_checkName(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CheckName__Result = CheckName__Result.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "checkName failed: unknown result"));
            }
        }
    }
    public recv_checkOptional(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CheckOptional__Result = CheckOptional__Result.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "checkOptional failed: unknown result"));
            }
        }
    }
    public recv_mapOneList(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: MapOneList__Result = MapOneList__Result.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "mapOneList failed: unknown result"));
            }
        }
    }
    public recv_mapValues(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: MapValues__Result = MapValues__Result.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "mapValues failed: unknown result"));
            }
        }
    }
    public recv_listToMap(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ListToMap__Result = ListToMap__Result.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "listToMap failed: unknown result"));
            }
        }
    }
    public recv_fetchThing(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: FetchThing__Result = FetchThing__Result.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "fetchThing failed: unknown result"));
            }
        }
    }
    public recv_fetchMap(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: FetchMap__Result = FetchMap__Result.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "fetchMap failed: unknown result"));
            }
        }
    }
    public recv_zip(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            input.readMessageEnd();
            return callback(undefined);
        }
    }
}
export interface ILocalHandler {
    ping(): void | Promise<void>;
    add(num1: number, num2: number): number | Promise<number>;
    addInt64(num1: Int64, num2: Int64): Int64 | Promise<Int64>;
    addWithContext(num1: number, num2: number): number | Promise<number>;
    calculate(logid: number, work: Work.Work): number | Promise<number>;
    echoBinary(word: Buffer): string | Promise<string>;
    echoString(word: string): string | Promise<string>;
    checkName(choice: Choice.Choice): string | Promise<string>;
    checkOptional(type?: string): string | Promise<string>;
    mapOneList(arg: Array<number>): Array<number> | Promise<Array<number>>;
    mapValues(arg: Map<string, number>): Array<number> | Promise<Array<number>>;
    listToMap(arg: Array<Array<string>>): Map<string, string> | Promise<Map<string, string>>;
    fetchThing(): com_test_common.CommonStruct | Promise<com_test_common.CommonStruct>;
    fetchMap(): TypedMap.TypedMap | Promise<TypedMap.TypedMap>;
    zip(): void | Promise<void>;
}
export type IHandler = ILocalHandler & __ROOT_NAMESPACE__.SharedService.IHandler;
export class Processor extends __ROOT_NAMESPACE__.SharedService.Processor {
    public _handler: IHandler;
    constructor(handler: IHandler) {
        super({
            getUnion: handler.getUnion,
            getEnum: handler.getEnum,
            getStruct: handler.getStruct
        });
        this._handler = handler;
    }
    public process(input: thrift.TProtocol, output: thrift.TProtocol): void {
        const metadata: thrift.TMessage = input.readMessageBegin();
        const fname: string = metadata.fname;
        const requestId: number = metadata.rseqid;
        const methodName: string = "process_" + fname;
        switch (methodName) {
            case "process_getUnion": {
                this.process_getUnion(requestId, input, output);
                return;
            }
            case "process_getEnum": {
                this.process_getEnum(requestId, input, output);
                return;
            }
            case "process_getStruct": {
                this.process_getStruct(requestId, input, output);
                return;
            }
            case "process_ping": {
                this.process_ping(requestId, input, output);
                return;
            }
            case "process_add": {
                this.process_add(requestId, input, output);
                return;
            }
            case "process_addInt64": {
                this.process_addInt64(requestId, input, output);
                return;
            }
            case "process_addWithContext": {
                this.process_addWithContext(requestId, input, output);
                return;
            }
            case "process_calculate": {
                this.process_calculate(requestId, input, output);
                return;
            }
            case "process_echoBinary": {
                this.process_echoBinary(requestId, input, output);
                return;
            }
            case "process_echoString": {
                this.process_echoString(requestId, input, output);
                return;
            }
            case "process_checkName": {
                this.process_checkName(requestId, input, output);
                return;
            }
            case "process_checkOptional": {
                this.process_checkOptional(requestId, input, output);
                return;
            }
            case "process_mapOneList": {
                this.process_mapOneList(requestId, input, output);
                return;
            }
            case "process_mapValues": {
                this.process_mapValues(requestId, input, output);
                return;
            }
            case "process_listToMap": {
                this.process_listToMap(requestId, input, output);
                return;
            }
            case "process_fetchThing": {
                this.process_fetchThing(requestId, input, output);
                return;
            }
            case "process_fetchMap": {
                this.process_fetchMap(requestId, input, output);
                return;
            }
            case "process_zip": {
                this.process_zip(requestId, input, output);
                return;
            }
            default: {
                input.skip(thrift.Thrift.Type.STRUCT);
                input.readMessageEnd();
                const errMessage = "Unknown function " + fname;
                const err = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN_METHOD, errMessage);
                output.writeMessageBegin(fname, thrift.Thrift.MessageType.EXCEPTION, requestId);
                err.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        }
    }
    public process_ping(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<void>((resolve, reject): void => {
            try {
                input.readMessageEnd();
                resolve(this._handler.ping());
            }
            catch (err) {
                reject(err);
            }
        }).then((data: void): void => {
            const result: Ping__Result = new Ping__Result({ success: data });
            output.writeMessageBegin("ping", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("ping", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_add(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<number>((resolve, reject): void => {
            try {
                const args: Add__Args = Add__Args.read(input);
                input.readMessageEnd();
                resolve(this._handler.add(args.num1, args.num2));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: number): void => {
            const result: Add__Result = new Add__Result({ success: data });
            output.writeMessageBegin("add", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof com_test_operation.JankyResult) {
                const result: Add__Result = new Add__Result({ exp: err });
                output.writeMessageBegin("add", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("add", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_addInt64(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Int64>((resolve, reject): void => {
            try {
                const args: AddInt64__Args = AddInt64__Args.read(input);
                input.readMessageEnd();
                resolve(this._handler.addInt64(args.num1, args.num2));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Int64): void => {
            const result: AddInt64__Result = new AddInt64__Result({ success: data });
            output.writeMessageBegin("addInt64", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof NotAGoodIdea.NotAGoodIdea) {
                const result: AddInt64__Result = new AddInt64__Result({ exp: err });
                output.writeMessageBegin("addInt64", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("addInt64", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_addWithContext(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<number>((resolve, reject): void => {
            try {
                const args: AddWithContext__Args = AddWithContext__Args.read(input);
                input.readMessageEnd();
                resolve(this._handler.addWithContext(args.num1, args.num2));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: number): void => {
            const result: AddWithContext__Result = new AddWithContext__Result({ success: data });
            output.writeMessageBegin("addWithContext", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("addWithContext", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_calculate(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<number>((resolve, reject): void => {
            try {
                const args: Calculate__Args = Calculate__Args.read(input);
                input.readMessageEnd();
                resolve(this._handler.calculate(args.logid, args.work));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: number): void => {
            const result: Calculate__Result = new Calculate__Result({ success: data });
            output.writeMessageBegin("calculate", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof com_test_operation.JankyOperation) {
                const result: Calculate__Result = new Calculate__Result({ ouch: err });
                output.writeMessageBegin("calculate", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("calculate", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_echoBinary(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<string>((resolve, reject): void => {
            try {
                const args: EchoBinary__Args = EchoBinary__Args.read(input);
                input.readMessageEnd();
                resolve(this._handler.echoBinary(args.word));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: string): void => {
            const result: EchoBinary__Result = new EchoBinary__Result({ success: data });
            output.writeMessageBegin("echoBinary", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("echoBinary", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_echoString(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<string>((resolve, reject): void => {
            try {
                const args: EchoString__Args = EchoString__Args.read(input);
                input.readMessageEnd();
                resolve(this._handler.echoString(args.word));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: string): void => {
            const result: EchoString__Result = new EchoString__Result({ success: data });
            output.writeMessageBegin("echoString", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("echoString", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_checkName(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<string>((resolve, reject): void => {
            try {
                const args: CheckName__Args = CheckName__Args.read(input);
                input.readMessageEnd();
                resolve(this._handler.checkName(args.choice));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: string): void => {
            const result: CheckName__Result = new CheckName__Result({ success: data });
            output.writeMessageBegin("checkName", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("checkName", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_checkOptional(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<string>((resolve, reject): void => {
            try {
                const args: CheckOptional__Args = CheckOptional__Args.read(input);
                input.readMessageEnd();
                resolve(this._handler.checkOptional(args.type));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: string): void => {
            const result: CheckOptional__Result = new CheckOptional__Result({ success: data });
            output.writeMessageBegin("checkOptional", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("checkOptional", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_mapOneList(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<number>>((resolve, reject): void => {
            try {
                const args: MapOneList__Args = MapOneList__Args.read(input);
                input.readMessageEnd();
                resolve(this._handler.mapOneList(args.arg));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<number>): void => {
            const result: MapOneList__Result = new MapOneList__Result({ success: data });
            output.writeMessageBegin("mapOneList", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("mapOneList", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_mapValues(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<number>>((resolve, reject): void => {
            try {
                const args: MapValues__Args = MapValues__Args.read(input);
                input.readMessageEnd();
                resolve(this._handler.mapValues(args.arg));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<number>): void => {
            const result: MapValues__Result = new MapValues__Result({ success: data });
            output.writeMessageBegin("mapValues", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("mapValues", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_listToMap(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Map<string, string>>((resolve, reject): void => {
            try {
                const args: ListToMap__Args = ListToMap__Args.read(input);
                input.readMessageEnd();
                resolve(this._handler.listToMap(args.arg));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Map<string, string>): void => {
            const result: ListToMap__Result = new ListToMap__Result({ success: data });
            output.writeMessageBegin("listToMap", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("listToMap", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_fetchThing(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<com_test_common.CommonStruct>((resolve, reject): void => {
            try {
                input.readMessageEnd();
                resolve(this._handler.fetchThing());
            }
            catch (err) {
                reject(err);
            }
        }).then((data: com_test_common.CommonStruct): void => {
            const result: FetchThing__Result = new FetchThing__Result({ success: data });
            output.writeMessageBegin("fetchThing", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("fetchThing", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_fetchMap(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TypedMap.TypedMap>((resolve, reject): void => {
            try {
                input.readMessageEnd();
                resolve(this._handler.fetchMap());
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TypedMap.TypedMap): void => {
            const result: FetchMap__Result = new FetchMap__Result({ success: data });
            output.writeMessageBegin("fetchMap", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("fetchMap", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_zip(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<void>((resolve, reject): void => {
            try {
                input.readMessageEnd();
                resolve(this._handler.zip());
            }
            catch (err) {
                reject(err);
            }
        }).then((data: void): void => {
            const result: Zip__Result = new Zip__Result({ success: data });
            output.writeMessageBegin("zip", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("zip", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
}
